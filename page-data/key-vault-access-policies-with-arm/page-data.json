{"componentChunkName":"component---src-templates-post-template-js","path":"/key-vault-access-policies-with-arm/","result":{"data":{"post":{"id":"5ed3a081-a2b3-587f-97cb-6fead614a564","html":"<p>Azure Resource Manager templates let you define access policies for your Key Vault instances, but there’s some undocumented behaviour around how the access policies are applied. I recently had a situation where I needed to use ARM to allow an App Service <a href=\"https://docs.microsoft.com/en-us/azure/app-service/overview-managed-identity\">managed identity</a> to access vault secrets but I <em>didn’t</em> want to cause any existing access policies on the vault to be removed.</p>\n<p>You can find the Azure Key Vault ARM resource documentation <a href=\"https://docs.microsoft.com/en-us/azure/templates/microsoft.keyvault/2019-09-01/vaults\">here</a>.</p>\n<p>In normal use, the access policies you define in the <code class=\"language-text\">accessPolicies</code> element will completely replace <em>any</em> other access policies that might exist on the vault. I did <em>not</em> want this behaviour. Basically I had to answer this question:</p>\n<blockquote>\n<p>How do I define Key Vault access policies in an ARM template so that the access policies are added if they don’t already exist (or updated if they do already exist) but <em>don’t</em> cause any other policies that might be on the Key Vault to be removed?</p>\n</blockquote>\n<p>This is possible, but a bit tricky, and relies (ab)using the <code class=\"language-text\">createMode</code> flag.</p>\n<blockquote>\n<p>TL-DR; when the vault doesn’t already exist use <code class=\"language-text\">createMode = create</code>, all other times use <code class=\"language-text\">createMode = recover</code></p>\n</blockquote>\n<p>But first we have to detour a bit into the Key Vault lifecycle and the concept of soft delete and purge protection.</p>\n<h2>Key Vault lifecycle</h2>\n<p>See the docs <a href=\"https://docs.microsoft.com/en-us/azure/key-vault/general/soft-delete-overview\">here</a>.</p>\n<p>Key Vaults have a lifecycle; they’re more than just provisioned (existing) or deleted (not-existing). When you delete a Key Vault instance that has soft-delete enabled, the vault goes into a soft-delete state, from which it can be recovered before the soft-delete retention period expires.</p>\n<p>Here’s one I’ve deleted. It’s in a soft-deleted state and and can be recovered. Notice the <code class=\"language-text\">-InRemovedState</code> switch parameter.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$&gt; Get-AzKeyVault -VaultName TonesKV1 -Location eastus -InRemovedState\n\nVault Name           : TonesKV1\nLocation             : eastus\nId                   : /subscriptions/********-****-****-****-************/providers/Microsoft.KeyVault/locations/eastus/deletedVaults/TonesKV1\nResource ID          : /subscriptions/********-****-****-****-************/resourceGroups/TonesKVBlog/providers/Microsoft.KeyVault/vaults/TonesKV1\nDeletion Date        : 26/08/2020 2:02:18 AM\nScheduled Purge Date : 2/09/2020 2:02:18 AM\nTags                 :</code></pre></div>\n<p>From here I could recover the vault (<code class=\"language-text\">Restore-AzKeyVault</code> or <code class=\"language-text\">az keyvault recover</code>), or purge it to permanently delete it (<code class=\"language-text\">Remove-AzKeyVault -InRemovedState</code> or <code class=\"language-text\">az keyvault purge</code>).</p>\n<p>Purge Protection is another layer of delete-protection that, if it’s enabled, prevents the vault from being purged. The docs describe how these features work together.</p>\n<p>But back to our problem with the access policies.</p>\n<h2>(Re)Deploying a Key Vault without removing existing access policies</h2>\n<p>This is where the <code class=\"language-text\">createMode</code> in flag comes in (see the <a href=\"https://docs.microsoft.com/en-us/azure/templates/microsoft.keyvault/2019-09-01/vaults\">ARM docs</a>, ctrl+f <code class=\"language-text\">createMode</code>).</p>\n<p><code class=\"language-text\">createMode</code> takes one of two values;</p>\n<ul>\n<li><code class=\"language-text\">create</code> - the default value, used to create a new vault (or update an existing one)</li>\n<li><code class=\"language-text\">recover</code> - used to recover a vault in a soft-deleted state, but can also be used on an existing active (non-soft-deleted) vault instance</li>\n</ul>\n<p>But they also have different impacts on how <code class=\"language-text\">accessPolicies</code> are applied to the vault.</p>\n<ul>\n<li>\n<p><code class=\"language-text\">createMode = create</code></p>\n<ul>\n<li>\n<p>Key Vault does not exist</p>\n<ul>\n<li>Creates the vault with the desired state.</li>\n<li>Access policies are applied as defined in the ARM template.</li>\n</ul>\n</li>\n<li>\n<p>KV exists and is active</p>\n<ul>\n<li>Updates the vault to the desired state.</li>\n<li>Access policies defined in the ARM template are added (or updated).</li>\n<li>Access policies <em>not</em> defined in the ARM template <strong>are removed</strong>.</li>\n</ul>\n</li>\n<li>\n<p>KV is soft-deleted</p>\n<ul>\n<li><em>Error</em></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">createMode = recover</code></p>\n<ul>\n<li>\n<p>Key Vault does not exist</p>\n<ul>\n<li><em>Error</em></li>\n</ul>\n</li>\n<li>\n<p>KV exists and is active</p>\n<ul>\n<li>Updates the vault to the desired state.</li>\n<li>Access policies defined in the ARM template are added (or updated).</li>\n<li>Access policies <em>not</em> defined in the ARM template <strong>remain unchanged</strong>.</li>\n</ul>\n</li>\n<li>\n<p>KV is soft-deleted</p>\n<ul>\n<li>Vault is recovered (no longer soft-deleted) and updated to desired state.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>From the options above, we can see that there is no single setting that does what we want. If we always used <code class=\"language-text\">create</code> then the access policies would get replaced every time we redeployed the ARM template, but if we always used <code class=\"language-text\">recover</code>, then the vault provisioning would fail if the vault doesn’t exist.</p>\n<h2>Are we any closer?</h2>\n<p>We can still get what we want: if the vault does not exist, we use <code class=\"language-text\">createMode = create</code>, but if the vault exists then we want <code class=\"language-text\">createMode = recover</code>.</p>\n<p>So we should be able to do something like;</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\">***snip the rest of the template***\n<span class=\"token property\">\"variables\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"doesVaultExist\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"[someFunctionToFindOutIfTheVaultExists()]\"</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token property\">\"resources\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n  <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"name\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"MyVault\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"type\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"Microsoft.KeyVault/vaults\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"apiVersion\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"2016-10-01\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"location\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"[resourceGroup().location]\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"properties\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token property\">\"tenantId\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"[resourceGroup().subscription.tenantId]\"</span><span class=\"token punctuation\">,</span>\n      <span class=\"token property\">\"createMode\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"[if(variables('doesVaultExist'),'recover', 'create')]\"</span><span class=\"token punctuation\">,</span>\n      <span class=\"token property\">\"accessPolicies\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n      <span class=\"token property\">\"sku\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token property\">\"name\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"standard\"</span><span class=\"token punctuation\">,</span> <span class=\"token property\">\"family\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"A\"</span> <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">]</span>\n***snip the rest of the template***</code></pre></div>\n<p>But this doesn’t work.</p>\n<p>We’re on the right track, but unfortunately ARM doesn’t provide any way to ask if a resource exists. All the ‘sane’ ways you might think of will result in an error. There’s a feature request on the Azure Feedback forum (formerly UserVoice) to add it (<a href=\"https://feedback.azure.com/forums/281804-azure-resource-manager/suggestions/38217556-introduce-function-to-check-whether-a-resource-exi\">here</a>). Yes - there are …unpleasant… ways to do it with nested templates or querying tags that <em>would have</em> been set by a previous deployment or some such, but they’re often not viable options.</p>\n<h2>So how do we do it?</h2>\n<p>Many ARM template deployments will involve some step before and/or after where you need to run some script and use Az CLI or Az PowerShell to do something you can’t do with ARM. This is the magic sauce.</p>\n<p>Change the above ARM template snippet to require you to pass in whether or not the key vault should be expected to exist. Instead of trying to derive the true/false value inside the template, you pass it in as a <code class=\"language-text\">parameter</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\">***snip the rest of the template***\n<span class=\"token property\">\"parameters\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"KeyVaultExists\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"type\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"bool\"</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token property\">\"resources\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n  <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"name\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"MyVault\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"type\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"Microsoft.KeyVault/vaults\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"apiVersion\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"2016-10-01\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"location\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"[resourceGroup().location]\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"properties\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token property\">\"tenantId\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"[resourceGroup().subscription.tenantId]\"</span><span class=\"token punctuation\">,</span>\n      <span class=\"token property\">\"createMode\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"[if(parameters('KeyVaultExists'),'recover', 'create')]\"</span><span class=\"token punctuation\">,</span>\n      <span class=\"token property\">\"accessPolicies\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n      <span class=\"token property\">\"sku\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token property\">\"name\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"standard\"</span><span class=\"token punctuation\">,</span> <span class=\"token property\">\"family\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"A\"</span> <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">]</span>\n***snip the rest of the template***</code></pre></div>\n<p>You then use Az CLI or Az PowerShell to see if the vault exists before you do the ARM deployment. In PowerShell, it’d look something like this;</p>\n<div class=\"gatsby-highlight\" data-language=\"powershell\"><pre class=\"language-powershell\"><code class=\"language-powershell\"><span class=\"token variable\">$exists</span> = <span class=\"token punctuation\">(</span><span class=\"token function\">Get-AzKeyVault</span> <span class=\"token operator\">-</span>VaultName <span class=\"token variable\">$vaultName</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-ne</span> <span class=\"token variable\">$null</span>\n<span class=\"token function\">New-AzResourceGroupDeployment</span> <span class=\"token operator\">-</span>ResourceGroupName <span class=\"token variable\">$rgName</span> <span class=\"token operator\">-</span>TemplateFile <span class=\"token variable\">$file</span> <span class=\"token operator\">-</span>KeyVaultExists <span class=\"token variable\">$exists</span></code></pre></div>\n<h2>But what if…</h2>\n<p>This method still has downsides.</p>\n<p>The biggest among them is the need to know the name up front. If your template implements a complicated or unpredictable naming scheme where you can’t know the vault name up front, then you’re out of luck. In my experience though, you can generally know or predict the name of the key vault so this isn’t such a big problem.</p>\n<p>It also requires you to run a script of some sort before you do the ARM deployment. This too isn’t often a big deal. You might already have a script where you can add the one-liner to query the existence of the vault. Or if you do your ARM deployment from a CD pipeline (Azure DevOps pipelines, GitHub Actions, etc), then it’s easy to add an extra step to query the existence of the vault and set a pipeline variable.</p>","fields":{"slug":"/key-vault-access-policies-with-arm/","prefix":"2020-08-26"},"frontmatter":{"title":"Azure Key Vault Access Policies with ARM","author":"Anthony Attwood","category":"azure","cover":{"childImageSharp":{"resize":{"src":"/static/a0950bc65a6272e1ffc6b023d4930ce4/9dc27/pexels-alex-knight-2599244.jpg"}}}}},"authornote":{"id":"6d7e2776-f5bf-5717-9502-2abc45ca50f5","html":"<p><strong>Anthony Attwood</strong> I’m a consultant software engineer living and working in Perth, Australia, building solutions that solve real problems for customers.</p>"}},"pageContext":{"slug":"/key-vault-access-policies-with-arm/","prev":{"id":"1c796584-f417-5954-b3da-f5b016fed17d","fields":{"slug":"/regional-vnet-integration-arm/","prefix":"2020-06-29","source":"posts"},"frontmatter":{"title":"Deploying Azure App Service Regional VNet Integration with ARM","category":"azure"}},"source":"posts"}},"staticQueryHashes":["2812560700","2812560700"]}